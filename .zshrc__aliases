#####################################################################
# Dev Utils
#####################################################################

#######################################
# Returns 0 if project is a yarn project, 1 if not. If it's not and it's a node project, this probably means it's npm we're working with
#
# Arguments: none
#######################################
is_yarn_project() {
  if [[ -e yarn.lock ]]; then
    return 0
  else
    return 1
  fi
}

format() {
  echo "üíÖ Formatting files with Prettier..."
  if is_yarn_project; then
    yarn prettier --write --loglevel=error .
  else
    npx prettier --write --loglevel=error .
  fi
  echo "‚úÖ Done formatting"
}
lint() {
  echo "üîé Linting files with ESLint..."
  yarn eslint .
  echo "‚úÖ Done linting"
}
tc() {
  echo "üßê Type-checking files with TypeScript..."
  yarn tsc $@ --noEmit
  echo "‚úÖ Done type-checking"
}
jest() {
  echo "üß™ Testing files changed on branch..."
  yarn jest --changedSince=$(git_dev_branch) --coverage=false $@
  echo "‚úÖ Done testing"
}
jestw() {
  echo "üß™üëÄ Testing files on watch..."
  yarn jest --watch --coverage=false $@
  echo "‚úÖ Done testing"
}
jestbw() {
  echo "üß™üëÄ Testing files changed on branch on watch..."
  yarn jest --changedSince=$(git_dev_branch) --watch --coverage=false $@
  echo "‚úÖ Done testing"
}
jesta() {
  echo "üß™ Testing all files..."
  yarn jest --coverage=false $@
  echo "‚úÖ Done testing"
}
# "validate static"
vs() {
  if is_yarn_project; then
    yarn
  else
    npm i
  fi

  # NOTE: Since concurrently doesn't have access to our functions/aliases above, we have to duplicate their commands here. So those and these should remain in sync
  # Using `npx` right now to reduce noise of saying `yarn run v1.x.x` right now, but could switch to yarn. Or could use bin below (but at that point, have to be in the project root for this to work. Or write some intelligent function that traverses upwards to find the project root, then use the `/node_modules/.bin` from there)
  # local bin="$(pwd)/node_modules/.bin"
  concurrently \
    -n typescript,eslint,prettier -c "#4077ba,#7b7ee3,#efbd52" \
    "npx tsc --noEmit" \
    "npx eslint ." \
    "npx prettier -write --loglevel=error ."
}
# "validate all" (static plus Jest tests)
va() {
  if git_has_changes; then
    echo "Uncommitted changes found; aborting."
    return
  fi

  if is_yarn_project; then
    yarn
  else
    npm i
  fi

  # NOTE: Since concurrently doesn't have access to our functions/aliases above, we have to duplicate their commands here. So those and these should remain in sync
  # Using `npx` right now to reduce noise of saying `yarn run v1.x.x` right now, but could switch to yarn. Or could use bin below (but at that point, have to be in the project root for this to work. Or write some intelligent function that traverses upwards to find the project root, then use the `/node_modules/.bin` from there)
  # local bin="$(pwd)/node_modules/.bin"
  concurrently \
    -n typescript,jest,eslint,prettier -c "#4077ba,#8f455b,#7b7ee3,#efbd52" \
    "npx tsc --noEmit" \
    "npx jest --changedSince=$(git_dev_branch) --coverage=false" \
    "npx eslint ." \
    "npx prettier -write --loglevel=error ."
}

#####################################################################
# Git
#####################################################################

# "git checkout branch"
alias gcob="git co -b"

# "git checkout main/dev"
# Also resets to HEAD, since that's pretty much always what I want when switching to one of these branches. Could also `git fetch` here before resetting to HEAD, but not sure if that's desirable yet + not necessary when in VS Code, since it fetches automatically in the background
alias gcom="git co \$(git_main_branch) && groh"
alias gcod="git co \$(git_dev_branch) && groh"
# Should probably only use these when trying to check out files from origin/dev or origin/main
# NOTE: Doing this (at least when the local version of the branch is not up-to-date, will put Git in a "detached head" state -- not just reset the local branch to origin's HEAD)
alias gcoom="git co origin/\$(git_main_branch)"
alias gcood="git co origin/\$(git_dev_branch)"

# "git checkout all"
alias gcoa="gco ."

# Override existing git aliases from the oh-my-zsh plugin to all use this custom `gc` alias, which uses `--no-verify`. This allows us to always circumvent pre-commit hooks that slow us down üôàü§∑‚Äç‚ôÇÔ∏è
alias gc="git commit --no-verify"
alias gcm="gc -m"
alias gcam="gc -am"
alias 'gc!'='gc -v --amend'
alias gca='gc -v -a'
alias 'gca!'='gc -v -a --amend'
alias gcam='gc -a -m'
alias 'gcan!'='gc -v -a --no-edit --amend'
alias 'gcans!'='gc -v -a -s --no-edit --amend'
alias gcmsg='gc -m'
alias 'gcn!'='gc -v --no-edit --amend'
alias gcs='gc -S'
alias gcsm='gc -s -m'

#######################################
# Returns 0 if there are any git changes,
# 1 if not
#
# Reference: https://stackoverflow.com/questions/3878624/how-do-i-programmatically-determine-if-there-are-uncommitted-changes
#######################################
git_has_changes() {
  # This is for edge cases/timestamps that I'm not sure I need yet, and is noisey, so I'm just ignoring it for now
  # git update-index --refresh

  ! git diff-index --quiet HEAD --
}

# "git commit lazy": Commit all if no staged changes, otherwise commit only staged files. Mirrors VS Code's behavior for commiting
gci() {
  if git diff --cached --quiet; then
    # No files are staged -- commit all unstaged changes
    git add -A -- .
    gc $@
  else
    # Files are staged -- only commit them
    gc $@
  fi
}
# Commit lazy, with a message
# NOTE: A copy of this logic (without using zsh aliases) exists as an executable in `bin` in this repository. See that script for details why
alias gcim="gci -m"

# "git pull origin main"
# `--no-edit` suppresses editing the commit message when doing the pull as a merge
alias gpom="git pull origin \$(git_main_branch) --no-edit"
# "git pull origin dev"
# `--no-edit` suppresses editing the commit message when doing the pull as a merge
alias gpod="git pull origin \$(git_dev_branch) --no-edit"

# "git diff origin dev"
alias gdod="git fetch && gd origin/\$(git_dev_branch)"
# "git diff origin main"
alias gdom="git fetch && gd origin/\$(git_main_branch)"

# Git diffing with origin/master and origin/<dev_branch>
alias gr="git rev"
alias grem="git remote" # (original oh-my-zsh `gr` alias)

# "git undo": "undoes" the last commit, and puts its changes back into the index
alias gundo="git reset HEAD~"
# "git undo soft/staged": "undoes" the last commit, and puts its changes into the staging area
alias gundos="git reset HEAD~ --soft"

# "git abandon": See .gitconfig alias for details
alias gab="git abandon"

# "git branch modify": Rename a branch
alias gbm="git branch -m"

alias gap="git add --patch"

# Remap oh-my-zsh's default `gup`
alias gpr="git pull --rebase"

# Quick committs with `gitupdate` go package
alias gup="gitupdate ."

# "git publish": See .gitcnofig alias for details
alias gpub="git publish"

# "git fixup": Quick fixup commits
# This one does all files, or just the ones staged, if any
alias gix="gcim 'fixup'"
# Explicitly select all files
alias gixa="gc -a -m 'fixup'"

# "git authors": See how many lines of code each dev/author is responsible for
# Source: https://stackoverflow.com/questions/4589731/git-blame-commit-statistics
alias gauth="git ls-tree -r -z --name-only HEAD -- $1 | xargs -0 -n1 git blame \

--line-porcelain HEAD |grep  '^author '|sort|uniq -c|sort -nr"

# "git merge continue": add all files that had conflicts, and finish the merge (skip editing the commit message, since `true` is working here as a no-op editor)
alias gmc="gaa && GIT_EDITOR=true gc"

# Change "git rebase continue" to skip editing the commit message (since `true` is working here as a no-op editor)
alias grbc="GIT_EDITOR=true git rebase --continue"
# "git rebase next": Add all files and continue the rebase
alias grbn="git add . && grbc"

# "git forget": Remove all files that used to be tracked, but aren't any longer (by gitignore)
alias gforget="git rm -r --cached . && git add ."

# "git conflicts": Show all files with conflicts (does so by using `git diff`, because in the case of rebase/merge conflicts, only conflict files will be in the index)
alias gconflicts="git diff --name-only | uniq"
# "git fix": Open all files with conflicts (in VS Code)
alias gfix="git diff --name-only | uniq | xargs code"

# "git show head"
alias gshh="git show HEAD"

git_dev_branch() {
  if [[ -n $(git branch --list develop) ]]; then
    echo develop
  elif [[ -n $(git branch --list development) ]]; then
    echo development
  elif [[ -n $(git branch --list main) ]]; then
    echo main
  else
    echo master
  fi
}

#####################################################################
# Bat and Delta
#####################################################################

# Decide the theme based on macOS dark mode
bat_theme="$(defaults read -globalDomain AppleInterfaceStyle &>/dev/null && echo default || echo GitHub)"
alias bat="bat --theme=$bat_theme"
alias cat="bat"

# Decide the theme based on macOS dark mode
delta_theme="$(defaults read -globalDomain AppleInterfaceStyle &>/dev/null && echo Monokai Extended || echo GitHub)"
alias delta="delta --syntax-theme=$delta_theme"

# To make sure git uses Delta, _with_ the theme we've decided on :)
export GIT_PAGER="delta --syntax-theme=$delta_theme"
# Oh, and since you can't use environment variables in your ~/.gitconfig, we're going to manually set the "system" gitconfig here based on $delta_theme, to make sure intractive git commands (e.g. `git add -p`) are also pretty üíÖ
git config --system interactive.diffFilter "delta --color-only --syntax-theme=$delta_theme"

#####################################################################
# npm
#####################################################################

alias ni="npm install"
alias nid="npm install -D"
alias nip="npm install -P"

#####################################################################
# yarn
#####################################################################

alias yst="yarn && yarn start"

#####################################################################
# Homebrew
#####################################################################

alias bi="brew install"

#####################################################################
# Miscellaneous
#####################################################################

# Open fzf files with vim by default
alias goto="vim -o \`fzf\`"
alias ls="exa"

# List directories
alias lsd="ls -d */"

# Log ip to console
alias myip="curl http://ipecho.net/plain; echo"

# Change ping to stop after 5 pings
alias ping="ping -c 5"

# I do these all the time when I'm mucking around with zsh/my .zshrc
alias ez="exec zsh"
alias sz="source ~/.zshrc"

alias alg="alias | grep"

# "bundle id": Given the path to an app, gives the app's bundle id
# Source: https://superuser.com/questions/346369/getting-the-bundle-identifier-of-an-os-x-application-in-a-shell-script
alias bid="mdls -name kMDItemCFBundleIdentifier -r"

alias wh=which

# Clears the screen and runs the succeeding command(s)
c() {
  clear
  eval $@
}
