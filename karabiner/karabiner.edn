;; !  | means mandatory -   modifier(s) alone when pressend change behavior
;; #  | means optional  -   modifiers are optional (but atleast one necessary)
;; ## | optional any
;; !! | command + control + optional + shift (hyper)
;; C  | left_command (Emacs: hyper)
;; T  | left_control (Emacs: control)
;; O  | left_option (Emacs: meta)
;; S  | left_shift
;; F  | fn (Emacs: super)
;; Q  | right_command (Emacs: control)
;; W  | right_control (Emacs: control)
;; E  | right_option (Emacs: )
;; R  | right_shift

{
  :profiles {
    :Goku {
      :default true
      :sim 40
      :delay 500
      :alone 200
      :held 250
    }
  }
  :simlayer-threshold 210

  :tos {
    :same_wind_app      {:key :grave_accent_and_tilde :modi [:left_command] :lazy true}
    :prev_app           {:key :tab :modi [:left_command] :lazy true}
    :left_paren         {:key :9 :modi [:left_shift] :lazy true}
    :right_paren        {:key :0 :modi [:left_shift] :lazy true}
    :left_control_lazy  {:key :left_control :lazy true}
    :left_cmd_lazy      {:key :left_command :lazy true}
  }

  :modifiers {
    :ro :right_option
  }

  :templates {
    :launch      "osascript -e 'tell application \"Alfred 4\" to run trigger \"launch%s\" in workflow \"yqrashawn.workflow.launcher\" with argument \"\"'"
    :alf         "open /Applications/Alfred\\ 4.app && osascript -e 'tell application \"Alfred 4\" to run trigger \"%s\" in workflow \"%s\"'"
    :open        "open \"%s\""
    :opena       "open -a \"%s\""
    :show        "osascript -e 'set appName to \"%s\"\nset startIt to false\ntell application \"System Events\"\n  if not (exists process appName) then\n    set startIt to true\n  else\n    set frontmost of process appName to true\n  end if\nend tell\nif startIt then\n  tell application appName to activate\nend if'\n"
    :toggle      "osascript -e 'set appName to \"%s\"\nset startIt to false\ntell application \"System Events\"\n  if not (exists process appName) then\n    set startIt to true\n  else if frontmost of process appName then\n    set visible of process appName to false\n  else\n    set frontmost of process appName to true\n  end if\nend tell\nif startIt then\n  tell application appName to activate\nend if'"
    :type        "osascript -e 'tell application \"System Events\" to keystroke \"%s\" as text'"
    :unicode      "osascript -e 'tell application \"System Events\" to keystroke (\"%s\" as Unicode text)'"
    ; :focus      "/usr/local/bin/yabai -m display --focus \"%s\" & /usr/local/bin/yabai -m space --focus \"%s\""
  }

  ; Layers: Pro is that you can hold down and do multiple simultaneously. Con is that if you type another character quickly, it won't register
  ; Simlayers: Pro is that it's super robust; can do multiple, never going to type something you don't want. Con is that it slows down the character getting registered (I think by the `:simlayer-threshold` below)

  :simlayers    {
    :launch-mode{ :key :x }
  }

  :main [
    ; Plain rule ideas:
      ; Swap ; and : (seems useful, but drifts away from normal keyboard a lot)
      ; Semicolon as shift key (pretty good -- might even help with ⌘+⇧ keybinding ergonomics)
    
    ; Simlayer ideas:
      ; Semicolon as app launcher (pretty awesome, especially if the delay isn't noticeable. Might be the move if we're okay with using a pinky for that)
      ; Using a simlayer for websites specifically (cool, but not sure if there's enough common websites for this to be worth it)
      ; Using a simlayer for symbols (punctuation, equals sign, brackets, etc.) (good for ergonomics, but has drift and requires another simlayer key)
      ; Having a simlayer for Alfred workflows (see Nikita's) (might be worth it someday, but those workflows are still maturing, and keywords are fine for now)
      ; Using a simlayer for the ctrl key, e.g. `a` (cool, but a simlayer on `a` is going to be hella annoying)
      ; Using a simlayer for mouse controls (might be useful for when we can see the mouse and we just want to bring focus to wherever it is)
      ; Using a simlayer for ⌘+⇧ (Nikita) (useful for ergonomics)
      ; Using a simlayer for ⌘ (Nikita) (useful for ergonomics)
      ; "Clone repo to ~/clones and open with VS Code" (Nikita) (could be cool -- could look into this)
      ; Using a simlayer for media controls (Nikita)
      ; Using a simlayer for common words/snippets (Nikita) (appears like it can only do it with actual keys/letters, and couldn't use unicode/emoji) (could use for `// TODO:`, "VSCode/XCode/Sublime comment on top of line with TODO", )
    
    ; Simlayer key ideas
      ; tilde
      ; semicolon
      ; backslash (currently used as ctrl key)
      ; tab
      ; slash
      ; period
      ; comma
      ; ======
      ; q, w, x, z, j, numbers
      ; https://en.wikipedia.org/wiki/Letter_frequency
    
    {
      :des "left cmd -> cmd+tab"
      :rules [[:left_command :left_command nil {:alone :!Ctab}]]
    }
    {
      :des "App-specific overrides"
      :rules [
        ; In Chrome, use left_option+enter to return focus to the document (Chrome doesn't provide any way to do this natively)
        ; Keybindings do this: 1) Focus the omnibar 2) type `j`, then `↵`. This runs a "search" I have in Chrome that runs no-op JavaScript, which in turn focuses the document
        [:!Oreturn_or_enter [:!Cl :j :return_or_enter] :Chrome]
        ; A backup (open preferences, then close the preferences tab)
        ; [:!Oreturn_or_enter [:!Ccomma :!Cw]]
      ]
    }
    {
      :des "caps_lock"
      :rules [
        ; The mandatory modifiers here are everything except right_shift (it's used down below for caps_lock)
        [:#CTOSFQWEcaps_lock :left_control_lazy nil {:alone :escape}]
      ]
    }
    {
      :des "enter"
      :rules [
        [:##return_or_enter :left_cmd_lazy nil {:alone :return_or_enter}]
      ]
    }
    {
      :des "backslash -> backslash (alone) left_control (held)"
 			:rules [
        [:backslash :left_control_lazy nil {:alone :backslash}]
      ]
    }
    {
      :des "right_shift + caps_lock -> caps_lock"
      :rules [
        [:!Rcaps_lock :caps_lock]
      ]
    }
    
    {
      :des "Disable cmd+tab"
      :rules [
        [:!Ctab :vk_none]
      ]
    }
    
    ; {
    ;   :des "launch mode"
    ;   :rules [
    ;     :launch-mode
    ;     ;  Most common apps
    ;     ; "Web"
    ;     [:w [:opena "Google Chrome"]]
    ;     ; This would be a nice-to-have, but has the downside of being a no-op if Chrome is open with no windows
    ;     ; [:w :same_wind_app :Chrome]
    ;     ; "Editor"
    ;     [:e [:opena "Visual Studio Code"] :!VSCode]
    ;     [:e :same_wind_app :VSCode]
    ;     ; [:s [:opena "Slack"]]
    ;     [:s [:opena "Slack Web"]]
    ;     [:t [:opena "Terminal"]]
        
    ;     ; Also common
    ;     [:q [:opena "Notes"]]
    ;     [:r [:opena "Trello"]]
    ;     [:x [:opena "Spotify"]]
    ;     [:z [:opena "zoom.us.app"]]
    ;     [:a [:opena "Alfred Preferences"]]
    ;     [:f [:opena "Finder"]]
    ;     [:c [:opena "Outlook"]]
        
    ;     ; Maybe... going to see how necessary these are. If they're not, we could use these for things other than just app launching
    ;     ; [:k [:opena "Karabiner-Elements"]]
    ;     ; [:l [:opena "Karabiner-EventViewer"]]
    ;     ; [:c [:opena "Music"]]
    ;     ; [:g [:opena "Messages"]]
    ;     ; email?
    ;   ]
    ; }
    
    {
      :des "launch mode (non-j)"
      :rules [
        :launch-mode
        ;  Most common apps
        ; Home row right
        ; *Just* browsin'
        [:j [:opena "Google Chrome"] :!Chrome]
        [:j :same_wind_app :Chrome]
        ; Kode
        [:k [:opena "Visual Studio Code"] :!VSCode]
        [:k :same_wind_app :VSCode]
        ; Some same/left hand alternatives
        [:c [:opena "Google Chrome"] :!Chrome]
        [:c :same_wind_app :Chrome]
        [:v [:opena "Visual Studio Code"] :!VSCode]
        [:k :same_wind_app :VSCode]
        ;  sLack
        ; [:l [:opena "Slack"]]
        [:l [:opena "Slack Web"]]
        [:semicolon [:opena "Terminal"]]
        
        ; Also common
        ;  Notes
        [:n [:opena "Notes"]]
        [:m [:opena "Trello"]]
        ; sPotify
        [:p [:opena "Spotify"]]
        [:i [:opena "Messages"]]
        ; zOOm
        [:o [:opena "zoom.us.app"]]
        [:quote [:opena "Music"]]
        ; todo: Open hey URL. Or just trigger alfred workflow
        [:y [:opena "Outlook"]]
        [:comma [:opena "System Preferences"]]
        [:period [:opena "Alfred Preferences"]]
        [:open_bracket [:opena "Preview"]]
        [:slash [:opena "Finder"]]
        
        ; Less common
        [:backslash [:opena "Activity Monitor"]]
        [:8 [:opena "Karabiner-Elements"]]
        [:7 [:opena "Karabiner-EventViewer"]]
      ]
    }
    
    {
      :des "Text navigation and manipulation"
      :rules [
        ; Char and word-wise nav
        [:!T#SRh :left_arrow]
        [:!T#SRj :down_arrow]
        [:!T#SRk :up_arrow]
        [:!T#SRl :right_arrow]
        [:!T#SRy :!Oleft_arrow]
        [:!T#SRo :!Oright_arrow]
        
        ; Char and word-wise deletion
        [:!Tu :!Odelete_or_backspace]
        [:!Ti :delete_or_backspace]
        [:!T7 :!Odelete_forward]
        [:!T8 :delete_forward]
        
        ; To start and end of line
        [:!Tn :!Cleft_arrow]
        [:!Tm :!Cright_arrow]
        [:!T#SRn :!Cleft_arrow]
        [:!T#SRm :!Cright_arrow]

        ; Line deletion
        ; Use Cocoa emacs bindings for apps that doesn't support ⌘+⌦ (i.e. Notes, Terminal)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Delete line backward
        [:!Tcomma :!Cdelete_or_backspace [:!Terminals]]
        [:!Tcomma :!Tu [:Terminals]]
        ; Delete line forward
        [:!Tperiod :!Cdelete_forward [:!Notes :!Terminals]]
        [:!Tperiod :!Tk]
        ; Delete full line
        [:!Tslash [:!Cright_arrow :!Cdelete_or_backspace] [:!Terminals :!VSCode]]
        ; Terminals don't support ⌘+← or ⌘+⌦. So instead, we rely on the original Cocoa Emacs commands for them
        [:!Tslash [:!Te :!Tu] :Terminals]
        ; For VS Code, it's trickier -- you want to preserve indentation, but also want it to behave nicely in the integrated terminal…
        [:!Tslash [:!Cright_arrow :!Cdelete_or_backspace] :VSCode]
        
        ; Clear everything
        [:!Tdelete_or_backspace [:!Ca :delete_or_backspace]]
        
        ; Page up/down
        [:!Oj :page_down]
        [:!Ok :page_up]
      ]
    }
  ]

  :applications {
    :VSCode ["^com\\.microsoft\\.VSCode(Insiders)?$"]
    :Chrome [
      "^com\\.google\\.Chrome$",
      "^org\\.chromium\\.Chromium$",
      "^com\\.google\\.Chrome\\.canary$"
    ]
    :Firefoxes [
      "^org\\.mozilla\\.firefox$",
      "^org\\.mozilla\\.firefoxdeveloperedition$"
    ]
    :Terminals [
      "^com\\.apple\\.Terminal$"
      "^com\\.googlecode\\.iterm2$"
      "^co\\.zeit\\.hyperterm$"
      "^co\\.zeit\\.hyper$"
      "^io\\.alacritty$"
      "^net\\.kovidgoyal\\.kitty$"
      ]
    :Finder ["^com\\.apple\\.finder$"]
    :Notes ["^com\\.apple\\.Notes$"]
    :Debuggers [
      "^org\\.mozilla\\.firefox$"
    "^org\\.mozilla\\.firefoxdeveloperedition$"
    "^com\\.google\\.Chrome$"
    "^org\\.chromium\\.Chromium$"
    "^com\\.google\\.Chrome\\.canary$"
    "^com\\.apple\\.Safari$"
    "^com\\.microsoft\\.VSCode(Insiders)?$"]
    :Alfred ["^com\\.runningwithcrayons\\.Alfred$"]
    :Keybase ["^keybase\\.Electron$"]
    :Browsers [
      "^org\\.mozilla\\.firefox$"
      "^org\\.mozilla\\.firefoxdeveloperedition$"
      "^com\\.google\\.Chrome$"
      "^org\\.chromium\\.Chromium$"
      "^com\\.google\\.Chrome\\.canary$"
      "^com\\.apple\\.Safari$"
    ]
  }
}